#!/usr/bin/env ruby
require 'rubygems'
require 'fileutils'
require 'optparse'
require 'do_stuff'

DO_STUFFRC = ENV['HOME'] + '/.do_stuffrc'
abort "Error: Couldn't find #{DO_STUFFRC}.\nPlease create it and put the " +
  "path to your todo.txt file in it." unless File.exists?(DO_STUFFRC)

TODO_FILE = File.expand_path(File.read(DO_STUFFRC).chomp)
FileUtils.mkdir_p(File.dirname(TODO_FILE))
FileUtils.touch(TODO_FILE)

program = File.basename($0)
USAGE = <<EOS
usage: #{program}               list unfinished tasks
       #{program} <task desc>   add a new task
       #{program} <task num>    erase task
       #{program} -e[task num]  edit task file and jump to given task
       #{program} -h            show this message
EOS

OptionParser.new do |opts|
  opts.on('-e [TASK NUM]') do |task_num|
    TodoList.edit(TODO_FILE)
    exit
  end

  opts.on('-h', '--help') do
    puts USAGE
    exit
  end
end.parse!

begin
  todolist = TodoList.new(TODO_FILE)
rescue TodoList::ParseError => e
  abort "Error parsing #{e.file}: #{e.message}"
end

if ARGV.length == 0
  todolist.tasks.each do |num, task|
    puts "#{num}. #{task}"
  end
elsif ARGV.length == 1 && ARGV[0] =~ /^\d+$/
  task_num = ARGV[0].to_i
  task = todolist.get(task_num)
  abort "There is no task ##{task_num}." unless task
  todolist.erase(task_num)
  todolist.write!
  puts "Erased ##{task_num}: #{task}"
else
  # If nothing else matches, treat the arguments as a task description.
  task = ARGV.join(' ')
  task_num = todolist.add(task)
  todolist.write!
  puts "Added ##{task_num}: #{task}"
end
